/*.$file${../::src::qm::qm_power.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: main.qm
* File:  ${../::src::qm::qm_power.c}
*
* This code has been generated by QM 5.0.1 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-EVAL
* Issued to   : Institution or an individual evaluating the QP/C framework
* Framework(s): qpc
* Support ends: 2020-12-31
* Product(s)  :
* This license is available only for evaluation purposes and
* the generated code is still licensed under the terms of GPL.
* Please submit request for extension of the evaluaion period at:
* <www.state-machine.com/licensing/#RequestForm>
*/
/*.$endhead${../::src::qm::qm_power.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qm/qm_power.h"
#include "base/base.h"

/*.$declare${base::qm_power} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_power} .......................................................*/
typedef struct {
/* protected: */
    QMActive super;

/* public: */
    QTimeEvt timer;
} qm_power;

/* protected: */
static QState qm_power_initial(qm_power * const me, QEvt const * const e);
static QState qm_power_start  (qm_power * const me, QEvt const * const e);
static QState qm_power_start_e(qm_power * const me);
static QMState const qm_power_start_s = {
    QM_STATE_NULL, /* superstate (top) */
    Q_STATE_CAST(&qm_power_start),
    Q_ACTION_CAST(&qm_power_start_e),
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_NULL  /* no initial tran. */
};
static QState qm_power_init  (qm_power * const me, QEvt const * const e);
static QState qm_power_init_e(qm_power * const me);
static QMState const qm_power_init_s = {
    QM_STATE_NULL, /* superstate (top) */
    Q_STATE_CAST(&qm_power_init),
    Q_ACTION_CAST(&qm_power_init_e),
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_NULL  /* no initial tran. */
};
/*.$enddecl${base::qm_power} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static qm_power l_qm_power;

QActive* const ao_qm_power = (QActive*)&l_qm_power;

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 670U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.7.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${base::qm_power_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_power_ctor} ..................................................*/
void qm_power_ctor(void) {
    qm_power *me = &l_qm_power;

    QMActive_ctor(&me->super, Q_STATE_CAST(&qm_power_initial));

    QTimeEvt_ctorX (&me->timer, &me->super, POWER_TIMEOUT_SIG, 0U);

}
/*.$enddef${base::qm_power_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$define${base::qm_power} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_power} .......................................................*/
/*.${base::qm_power::SM} ...................................................*/
static QState qm_power_initial(qm_power * const me, QEvt const * const e) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* tran-action table */
        &qm_power_init_s, /* target state */
        {
            Q_ACTION_CAST(&qm_power_init_e), /* entry */
            Q_ACTION_NULL /* zero terminator */
        }
    };
    /*.${base::qm_power::SM::initial} */
    QActive_subscribe((QActive *)me, POWER_ON_SIG);
    return QM_TRAN_INIT(&tatbl_);
}
/*.${base::qm_power::SM::start} ............................................*/
/*.${base::qm_power::SM::start} */
static QState qm_power_start_e(qm_power * const me) {
    LOG("power start");

    QTimeEvt_armX(&me->timer,  QF_TICKS_PER_SEC, QF_TICKS_PER_SEC);

    //notify others actors to start
    QEvt *pe = Q_NEW(QEvt, POWER_START_SIG);
    QF_PUBLISH((QEvt*)pe, NULL);

    return QM_ENTRY(&qm_power_start_s);
}
/*.${base::qm_power::SM::start} */
static QState qm_power_start(qm_power * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* unused parameter */
    return status_;
}
/*.${base::qm_power::SM::init} .............................................*/
/*.${base::qm_power::SM::init} */
static QState qm_power_init_e(qm_power * const me) {

    QEvt *pe = Q_NEW(QEvt, POWER_ON_SIG);
    QF_PUBLISH((QEvt*)pe, NULL);

    (void)me; /* unused parameter */
    return QM_ENTRY(&qm_power_init_s);
}
/*.${base::qm_power::SM::init} */
static QState qm_power_init(qm_power * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${base::qm_power::SM::init::POWER_ON} */
        case POWER_ON_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* tran-action table */
                &qm_power_start_s, /* target state */
                {
                    Q_ACTION_CAST(&qm_power_start_e), /* entry */
                    Q_ACTION_NULL /* zero terminator */
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*.$enddef${base::qm_power} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
