/*.$file${../::src::qm::qm_led.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: led.qm
* File:  ${../::src::qm::qm_led.c}
*
* This code has been generated by QM 5.0.1 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-EVAL
* Issued to   : Institution or an individual evaluating the QP/C framework
* Framework(s): qpc
* Support ends: 2020-12-31
* Product(s)  :
* This license is available only for evaluation purposes and
* the generated code is still licensed under the terms of GPL.
* Please submit request for extension of the evaluaion period at:
* <www.state-machine.com/licensing/#RequestForm>
*/
/*.$endhead${../::src::qm::qm_led.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qm/qm_led.h"
#include "base/base.h"

/*.$declare${base::qm_led} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_led} .........................................................*/
typedef struct {
/* protected: */
    QMActive super;

/* public: */
    QTimeEvt timer;
} qm_led;

/* protected: */
static QState qm_led_initial(qm_led * const me, QEvt const * const e);
static QState qm_led_start  (qm_led * const me, QEvt const * const e);
static QState qm_led_start_e(qm_led * const me);
static QState qm_led_start_i(qm_led * const me);
static QMState const qm_led_start_s = {
    QM_STATE_NULL, /* superstate (top) */
    Q_STATE_CAST(&qm_led_start),
    Q_ACTION_CAST(&qm_led_start_e),
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_CAST(&qm_led_start_i)
};
static QState qm_led_on  (qm_led * const me, QEvt const * const e);
static QState qm_led_on_e(qm_led * const me);
static QMState const qm_led_on_s = {
    &qm_led_start_s, /* superstate */
    Q_STATE_CAST(&qm_led_on),
    Q_ACTION_CAST(&qm_led_on_e),
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_NULL  /* no initial tran. */
};
static QState qm_led_off  (qm_led * const me, QEvt const * const e);
static QState qm_led_off_e(qm_led * const me);
static QMState const qm_led_off_s = {
    &qm_led_start_s, /* superstate */
    Q_STATE_CAST(&qm_led_off),
    Q_ACTION_CAST(&qm_led_off_e),
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_NULL  /* no initial tran. */
};
static QState qm_led_init  (qm_led * const me, QEvt const * const e);
static QMState const qm_led_init_s = {
    QM_STATE_NULL, /* superstate (top) */
    Q_STATE_CAST(&qm_led_init),
    Q_ACTION_NULL, /* no entry action */
    Q_ACTION_NULL, /* no exit action */
    Q_ACTION_NULL  /* no initial tran. */
};
/*.$enddecl${base::qm_led} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


static qm_led l_qm_led;

QActive* const ao_qm_led = (QActive*)&l_qm_led;

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 670U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.7.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${base::qm_led_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_led_ctor} ....................................................*/
void qm_led_ctor(void) {
    qm_led *me = &l_qm_led;
    QMActive_ctor(&me->super, Q_STATE_CAST(&qm_led_initial));

    QTimeEvt_ctorX (&me->timer, &me->super, LED_TIMEOUT_SIG, 0U);

}
/*.$enddef${base::qm_led_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${base::qm_led} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${base::qm_led} .........................................................*/
/*.${base::qm_led::SM} .....................................................*/
static QState qm_led_initial(qm_led * const me, QEvt const * const e) {
    static QMTranActTable const tatbl_ = { /* tran-action table */
        &qm_led_init_s, /* target state */
        {
            Q_ACTION_NULL /* zero terminator */
        }
    };
    /*.${base::qm_led::SM::initial} */
    QActive_subscribe((QActive *)me, POWER_START_SIG);

    return QM_TRAN_INIT(&tatbl_);
}
/*.${base::qm_led::SM::start} ..............................................*/
/*.${base::qm_led::SM::start} */
static QState qm_led_start_e(qm_led * const me) {
    LOG("led active");

    QTimeEvt_armX(&me->timer,  QF_TICKS_PER_SEC, QF_TICKS_PER_SEC);
    return QM_ENTRY(&qm_led_start_s);
}
/*.${base::qm_led::SM::start::initial} */
static QState qm_led_start_i(qm_led * const me) {
    static struct {
        QMState const *target;
        QActionHandler act[2];
    } const tatbl_ = { /* tran-action table */
        &qm_led_on_s, /* target state */
        {
            Q_ACTION_CAST(&qm_led_on_e), /* entry */
            Q_ACTION_NULL /* zero terminator */
        }
    };
    /*.${base::qm_led::SM::start::initial} */
    return QM_TRAN_INIT(&tatbl_);
}
/*.${base::qm_led::SM::start} */
static QState qm_led_start(qm_led * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* unused parameter */
    return status_;
}
/*.${base::qm_led::SM::start::on} ..........................................*/
/*.${base::qm_led::SM::start::on} */
static QState qm_led_on_e(qm_led * const me) {

    LOG("led on");

    led_switch(true);

    //adc_get_value();

    //adc_convert();
    (void)me; /* unused parameter */
    return QM_ENTRY(&qm_led_on_s);
}
/*.${base::qm_led::SM::start::on} */
static QState qm_led_on(qm_led * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${base::qm_led::SM::start::on::LED_TIMEOUT} */
        case LED_TIMEOUT_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* tran-action table */
                &qm_led_off_s, /* target state */
                {
                    Q_ACTION_CAST(&qm_led_off_e), /* entry */
                    Q_ACTION_NULL /* zero terminator */
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*.${base::qm_led::SM::start::off} .........................................*/
/*.${base::qm_led::SM::start::off} */
static QState qm_led_off_e(qm_led * const me) {

    LOG("led off");

    led_switch(false);
    (void)me; /* unused parameter */
    return QM_ENTRY(&qm_led_off_s);
}
/*.${base::qm_led::SM::start::off} */
static QState qm_led_off(qm_led * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${base::qm_led::SM::start::off::LED_TIMEOUT} */
        case LED_TIMEOUT_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[2];
            } const tatbl_ = { /* tran-action table */
                &qm_led_on_s, /* target state */
                {
                    Q_ACTION_CAST(&qm_led_on_e), /* entry */
                    Q_ACTION_NULL /* zero terminator */
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*.${base::qm_led::SM::init} ...............................................*/
/*.${base::qm_led::SM::init} */
static QState qm_led_init(qm_led * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${base::qm_led::SM::init::POWER_START} */
        case POWER_START_SIG: {
            static struct {
                QMState const *target;
                QActionHandler act[3];
            } const tatbl_ = { /* tran-action table */
                &qm_led_start_s, /* target state */
                {
                    Q_ACTION_CAST(&qm_led_start_e), /* entry */
                    Q_ACTION_CAST(&qm_led_start_i), /* initial tran. */
                    Q_ACTION_NULL /* zero terminator */
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
/*.$enddef${base::qm_led} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
